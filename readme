Тестовое задание:
Задача: Реализовать консольное приложение, которое выполняет перебор и протоколирование ключей реестра, 
соответствующих заданному текстовому шаблону, в файл, начиная с заданного пути в реестре.

Дополнительные требования:

Желательно реализовать возможность отображения прогресса выполнения операции любым доступным способом.

Входные данные:
- Начальный узел реестра в HKLM. Если узел не задан, то используется корень HKLM.
- Подстрока которая ищется в имени ключа реестра. Если подстрока соответствия не задана, то сохраняются 
все строки.

Выходные данные:
- Файл с перечнем ключей реестра, соответствующих заданному условию (каждая строка включает в себя 
полный путь и имя ключа реестра разделенные символом слеш).
- Сообщение об окончании операции и количестве найденных соответствий или что соответствие не найдено.

Примечание:
- Соответствие любым разумным стандартам кодирования будет плюсом.
- Исходный код решения и артефакты сборки необходимо разместить в онлайн репозитории на ваш выбор.
- Приветствуется наличие проектной документации и адекватное комментирование кода.

- Все детали задачи требуют минимальной реализации и скромной обработки ошибок, чтобы уменьшить объем 
тестовой задачи.

--------------------------------------------------

Замечания по первоначальной версии.
TL скинул несколько вопросов:
1. Почему не выполнено требование "Исходный код решения и артефакты сборки необходимо разместить в онлайн 
репозитории на ваш выбор."?
2. Почему не реализовано обязательное требование "Сообщение об окончании операции и количестве найденных 
соответствий или что соответствие не найдено."?
3. Прогресс реализован в виде отображения имени ключа. Почему бы не сделать было подсчет общего количества 
ключей? Кроме того, обрезание до 80 символов не позволит отобразить процесс для длинных ключей реестра.
4. Почему не сделано регистронезависимость параметров p и s? Зачем обработка параметров через позиции 
символов и дублирование обработки параметров?
5. Почему запись в файл производится по окончании операции а не в процессе работы?
6. Почему в файл не попадает начальный ключ? Кроме того, начальный ключ не проверяется на условие поиска.
7. Чем вызвано использование нескольких глобальных переменных?
8. Так как WinAPI используют многобайтные строки, будет производится неявная конвертация типов строк при 
использовании AnsiPos. Следует ли это исправить и как?
9. Зачем делать 2 раза операцию IncludeTrailingPathDelimiter(key + subKeys[i])?

--------------------------------------------------

Ответ на "Замечания по первоначальной версии."
1. Почему не выполнено требование "Исходный код решения и артефакты сборки необходимо разместить в онлайн 
репозитории на ваш выбор."?
Создал. https://github.com/valkuznetsoff/test

2. Почему не реализовано обязательное требование "Сообщение об окончании операции и количестве найденных 
соответствий или что соответствие не найдено."?
Исправил.

3. Прогресс реализован в виде отображения имени ключа. Почему бы не сделать было подсчет общего количества 
ключей? Кроме того, обрезание до 80 символов не позволит отобразить процесс для длинных ключей реестра.
Исправил.

4. Почему не сделано регистронезависимость параметров p и s? Зачем обработка параметров через позиции 
символов и дублирование обработки параметров?
Для параметра /s используется LowerCase, а для параметра /p регистронезависимость не требуется. 
Параметры /p и /s могут быть в произвольном порядке, кроме того один или оба параметра могут отсутствовать.

5. Почему запись в файл производится по окончании операции а не в процессе работы?
В процессе работы заполняется список найденных ключей и в финальной секции происходит полная запись 
всех значений на диск, что в итоге должно повлиять на скорость работы. Кроме того, если поиск вести 
в разных потоках, то в финальной секции можно сделать сортировку списка.

6. Почему в файл не попадает начальный ключ? Кроме того, начальный ключ не проверяется на условие поиска.
Исправил.

7. Чем вызвано использование нескольких глобальных переменных?
var
  str: string; // Вспомогательная переменная для распарсивания командной строки
  Cancel: boolean; // Флаг остановки процесса сканирования
  FoundKeys: TStringList; // Список найденных согласно условия ключей
  StartKey, SearchStr: string; // Начальный ключ и искомая строка. Искомая строка всегда одинаковая, 
                               // постоянно передавать ее параметром  в процедуру не имеет смысла.
  iCheckKeys, iFoundKeys: integer; // Общее количество  ключей и количество найденных ключей.

8. Так как WinAPI используют многобайтные строки, будет производится неявная конвертация типов строк при 
использовании AnsiPos. Следует ли это исправить и как?
Исправил. Вместо AnsiPos использую обычную Pos, вместо AnsiLowerCase - LowerCase.

9. Зачем делать 2 раза операцию IncludeTrailingPathDelimiter(key + subKeys[i])?
Исправил.

--------------------------------------------------
